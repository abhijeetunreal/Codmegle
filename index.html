<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Codmegle - Talk to Strangers</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link rel="stylesheet" href="css/chat.css">
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 400;
            letter-spacing: -0.01em;
        }
        
        /* Mobile optimizations */
        @media (max-width: 640px) {
            body {
                -webkit-tap-highlight-color: transparent;
            }
            /* Prevent zoom on input focus on iOS */
            input, textarea, select {
                font-size: 16px !important;
            }
        }
        
        /* Desktop optimizations */
        @media (min-width: 1024px) {
            .container-max {
                max-width: 1400px;
                margin: 0 auto;
            }
        }
        /* Scrollbar styling - now handled by chat.css */
        .scale-x-flip { transform: scaleX(-1); }
        
        /* Custom gradient backgrounds - using CSS variables from chat.css */
        .bg-gradient-primary {
            background: var(--button-primary-bg);
        }
        .bg-gradient-message-you {
            background: var(--message-you-bg);
        }
        .bg-gradient-message-stranger {
            background: var(--message-stranger-bg);
            border: 1px solid var(--message-stranger-border);
        }
        
        /* Smooth transitions */
        * {
            transition-property: color, background-color, border-color, transform, opacity;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 200ms;
        }
        
        /* Button hover effects */
        .btn-primary {
            transition: all 0.2s ease;
        }
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px -5px rgba(59, 130, 246, 0.4);
        }
        .btn-primary:active {
            transform: translateY(0);
        }
        
        /* Message bubble animation */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .message-bubble {
            animation: slideIn 0.3s ease-out;
        }
        
        /* Pulse animation for status */
        @keyframes pulse-slow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .pulse-slow {
            animation: pulse-slow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        /* Prevent clipping issues */
        #welcome-screen {
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }
        
        #welcome-screen > div {
            width: 100%;
            max-width: min(100% - 2rem, 48rem);
            box-sizing: border-box;
        }
        
        #welcome-screen h1,
        #welcome-screen p,
        #welcome-screen ul,
        #welcome-screen li {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden body-theme">

    <!-- Header -->
    <header class="header-main border-b p-2.5 sm:p-3 md:p-4 flex justify-between items-center shadow-md header-responsive shrink-0 z-10 backdrop-blur-sm">
        <div class="flex items-center select-none cursor-pointer group" onclick="window.location.reload()">
            <span class="text-xl sm:text-2xl md:text-3xl font-extrabold tracking-tight header-logo-text group-hover:text-blue-600 transition-colors">Cod</span>
            <span class="text-xl sm:text-2xl md:text-3xl font-extrabold tracking-tight text-white bg-gradient-to-r from-orange-500 to-orange-600 px-1 sm:px-1.5 md:px-2 py-0.5 transform -rotate-2 shadow-lg inline-block ml-0.5 sm:ml-1 rounded-md group-hover:shadow-xl transition-shadow">megle</span>
        </div>
        <div class="flex items-center gap-2 sm:gap-2.5 md:gap-3">
            <button id="theme-toggle" onclick="app.toggleTheme()" class="theme-toggle-btn flex items-center justify-center w-9 h-9 sm:w-10 sm:h-10 rounded-lg transition-all active:scale-95" title="Toggle theme">
                <i data-lucide="sun" class="w-5 h-5 theme-icon-light"></i>
                <i data-lucide="moon" class="w-5 h-5 theme-icon-dark hidden"></i>
            </button>
            <div class="h-1.5 w-1.5 sm:h-2 sm:w-2 bg-green-500 rounded-full pulse-slow"></div>
            <div class="text-xs sm:text-sm md:text-base header-online-text font-semibold px-1.5 sm:px-2 md:px-3 py-0.5 sm:py-1 md:py-1.5 header-online-bg rounded-full whitespace-nowrap header-online-count" id="online-count">
                Connecting...
            </div>
        </div>
    </header>

    <!-- Welcome Screen -->
    <div id="welcome-screen" class="flex-1 flex flex-col items-center justify-center p-4 sm:p-6 text-center overflow-y-auto" style="overflow-x: hidden; width: 100%;">
        <div class="p-6 sm:p-8 md:p-10 lg:p-12 rounded-xl sm:rounded-2xl shadow-2xl max-w-3xl w-full transform transition-all duration-300 hover:shadow-3xl mx-2 sm:mx-4" style="background-color: var(--bg-primary); border: 1px solid var(--border-primary); box-sizing: border-box; max-width: min(100% - 2rem, 48rem);">
            <div class="mb-6 sm:mb-8" style="width: 100%; box-sizing: border-box;">
                <h1 class="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-extrabold mb-3 sm:mb-4 bg-gradient-to-r from-blue-600 via-blue-500 to-blue-600 bg-clip-text text-transparent" style="word-wrap: break-word; overflow-wrap: break-word; padding: 9px 1rem; box-sizing: border-box;">
                    Talk to strangers!
                </h1>
                <p class="mb-2 text-base sm:text-lg md:text-xl leading-relaxed max-w-2xl mx-auto" style="color: var(--text-secondary); word-wrap: break-word; overflow-wrap: break-word; padding: 0 0.5rem; box-sizing: border-box;">
                    Codmegle is a great place to meet new friends. When you use Codmegle, 
                    we pick someone else at random and let you talk one-on-one.
                </p>
            </div>
            
            <div class="border-l-4 p-4 sm:p-5 mb-6 sm:mb-8 md:mb-10 text-left rounded-r-lg shadow-sm" style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(234, 179, 8, 0.1) 100%); border-color: #f59e0b; width: 100%; box-sizing: border-box;">
                <div class="flex items-start gap-3" style="width: 100%; box-sizing: border-box;">
                    <i data-lucide="alert-triangle" class="w-5 h-5 mt-0.5 flex-shrink-0" style="color: #f59e0b;"></i>
                    <div class="flex-1" style="min-width: 0; box-sizing: border-box;">
                        <p class="font-bold mb-2 text-base" style="color: var(--text-primary); word-wrap: break-word; overflow-wrap: break-word;">Terms of Service:</p>
                        <ul class="list-disc list-inside space-y-1.5 text-sm" style="color: var(--text-secondary); word-wrap: break-word; overflow-wrap: break-word;">
                            <li>You must be 18+ to use this site.</li>
                            <li>Do not transmit nudity, sexually explicit content, or illegal material.</li>
                            <li>Be respectful to others.</li>
                            <li><strong>Opening two tabs allows you to chat with yourself for testing!</strong></li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="space-y-4 sm:space-y-6" style="width: 100%; box-sizing: border-box;">
                <div class="font-semibold mb-3 sm:mb-4 text-base sm:text-lg" style="color: var(--text-primary); word-wrap: break-word; overflow-wrap: break-word;">Start chatting:</div>
                <div class="flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center" style="width: 100%; box-sizing: border-box; padding: 0 0.5rem;">
                    <button onclick="app.startChat('text')" class="btn-primary w-full sm:w-auto px-8 sm:px-10 py-4 sm:py-5 border-2 font-bold text-base sm:text-lg rounded-xl shadow-md active:translate-y-0.5 flex items-center justify-center gap-2 transition-all chat-header-btn" style="background-color: var(--button-secondary-bg); border-color: var(--button-secondary-border); color: var(--text-primary); box-sizing: border-box; flex-shrink: 1;">
                        <i data-lucide="message-square" class="w-5 h-5 flex-shrink-0"></i>
                        <span class="whitespace-nowrap">Text only</span>
                    </button>
                    <button onclick="app.startChat('video')" class="btn-primary w-full sm:w-auto px-8 sm:px-10 py-4 sm:py-5 bg-gradient-primary text-white font-bold text-base sm:text-lg rounded-xl hover:shadow-xl shadow-lg active:translate-y-0.5 flex items-center justify-center gap-2 transition-all" style="box-sizing: border-box; flex-shrink: 1;">
                        <i data-lucide="video" class="w-5 h-5 flex-shrink-0"></i>
                        <span class="whitespace-nowrap">Video</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

        <!-- Chat Screen -->
        <div id="chat-screen" class="hidden flex-1 flex flex-col h-full overflow-hidden" style="background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);">
        
        <!-- Video Container -->
        <div id="video-container" class="hidden h-48 sm:h-64 md:h-80 lg:h-96 relative flex justify-center items-center shrink-0 border-b-2 shadow-2xl" style="background: var(--video-bg); border-color: var(--border-primary);">
            <div class="w-full h-full relative">
                <!-- Remote Video Placeholder -->
                <div class="w-full h-full flex items-center justify-center" id="remote-video-container" style="background: var(--video-bg);">
                    <div class="text-center">
                        <div class="pulse-slow mb-4">
                            <div class="mx-auto w-16 h-16 rounded-full flex items-center justify-center" style="background: rgba(59, 130, 246, 0.15); backdrop-filter: blur(10px);">
                                <i data-lucide="video" class="w-8 h-8" style="color: var(--accent-primary);"></i>
                            </div>
                        </div>
                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Waiting for remote video...</p>
                    </div>
                </div>
                <div id="video-waiting-msg" class="absolute inset-0 flex items-center justify-center backdrop-blur-sm hidden" style="background: var(--video-overlay);">
                    <div class="text-center">
                        <div class="pulse-slow mb-3">
                            <div class="mx-auto w-12 h-12 rounded-full flex items-center justify-center" style="background: rgba(59, 130, 246, 0.15); backdrop-filter: blur(10px);">
                                <i data-lucide="users" class="w-6 h-6" style="color: var(--accent-primary);"></i>
                            </div>
                        </div>
                        <p class="font-semibold" style="color: var(--text-inverse);">Waiting for partner...</p>
                    </div>
                </div>

                <!-- Local Video -->
                <div class="absolute bottom-2 right-2 sm:bottom-4 sm:right-4 w-24 h-18 sm:w-32 sm:h-24 md:w-40 md:h-30 lg:w-48 lg:h-36 border-2 sm:border-4 shadow-2xl overflow-hidden rounded-lg sm:rounded-xl ring-1 sm:ring-2" style="background-color: #1f2937; border-color: rgba(255, 255, 255, 0.2); box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.5), 0 0 0 2px rgba(59, 130, 246, 0.5);">
                    <video id="local-video" autoplay playsinline muted class="w-full h-full object-cover scale-x-flip"></video>
                    <div id="no-camera-msg" class="hidden w-full h-full flex items-center justify-center text-white text-xs backdrop-blur-sm absolute inset-0 z-10" style="background: rgba(31, 41, 55, 0.8);">
                        <div class="text-center">
                            <i data-lucide="video-off" class="w-6 h-6 mx-auto mb-1"></i>
                            <p>No Camera</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Messages Area -->
        <div class="flex-1 flex flex-col overflow-hidden relative" style="background-color: var(--bg-primary);">
            <div id="messages-container" class="flex-1 overflow-y-auto p-4 md:p-6 space-y-3 font-sans" style="background-color: var(--bg-primary);">
                <div class="text-center py-4">
                    <div class="inline-flex items-center gap-2 px-4 py-2 rounded-full" style="background: linear-gradient(135deg, var(--accent-primary-light) 0%, rgba(59, 130, 246, 0.1) 100%); border: 1px solid var(--border-primary);">
                        <div class="h-2 w-2 rounded-full pulse-slow" style="background-color: var(--accent-primary);"></div>
                        <span class="text-sm font-medium italic" style="color: var(--accent-primary);">You're talking to a random stranger. Say Hi!</span>
                    </div>
                </div>
                <!-- Messages will be injected here -->
            </div>
            
            <div id="status-indicator" class="status-indicator px-6 py-4 border-t hidden">
                <div class="flex items-center justify-center gap-3">
                    <div class="flex gap-1.5">
                        <div class="h-2 w-2 status-dot pulse-slow" style="animation-delay: 0s"></div>
                        <div class="h-2 w-2 status-dot pulse-slow" style="animation-delay: 0.2s"></div>
                        <div class="h-2 w-2 status-dot pulse-slow" style="animation-delay: 0.4s"></div>
                    </div>
                    <p class="status-indicator-text font-semibold text-sm">Looking for someone you can chat with...</p>
                </div>
            </div>
            <div id="disconnect-indicator" class="px-6 py-4 border-t hidden" style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%); border-color: var(--status-error);">
                <div class="flex items-center justify-center gap-2">
                    <i data-lucide="alert-circle" class="w-5 h-5" style="color: var(--status-error);"></i>
                    <p class="font-bold text-sm" style="color: var(--status-error);">Stranger has disconnected.</p>
                </div>
            </div>

            <!-- Input Controls -->
            <div class="p-3 sm:p-4 md:p-6 border-t flex flex-col sm:flex-row items-stretch sm:items-center gap-2 sm:gap-3 shrink-0 shadow-lg" style="background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%); border-color: var(--border-primary);">
                <button id="btn-stop-next" onclick="app.handleStopNext()" class="h-11 sm:h-12 px-4 sm:px-6 font-bold rounded-xl shadow-md text-xs sm:text-sm uppercase tracking-wide transition-all border-2 active:translate-y-0.5 flex-shrink-0 justify-center items-center chat-header-btn stop-btn" style="background-color: var(--button-secondary-bg); border-color: var(--button-secondary-border); color: var(--text-primary);">
                    <span class="flex items-center gap-1.5">
                        <i data-lucide="arrow-right" class="w-4 h-4"></i>
                    </span>
                    <span class="ml-1 text-xs hidden sm:block -mt-0.5" style="color: var(--text-tertiary);">Esc</span>
                </button>

                <div class="flex-1 relative flex items-center">
                    <input type="text" id="msg-input" placeholder="Waiting..." disabled
                        class="message-input w-full h-11 sm:h-12 pl-4 sm:pl-5 pr-12 sm:pr-14 rounded-xl border-2 focus:outline-none focus:ring-2 disabled:cursor-not-allowed font-medium shadow-sm transition-all text-sm sm:text-base">
                    <button id="btn-send" onclick="app.sendMessage()" disabled
                        class="absolute right-2 top-1/2 transform -translate-y-1/2 h-7 w-7 sm:h-8 sm:w-8 flex items-center justify-center rounded-lg bg-gradient-primary text-white hover:shadow-lg disabled:opacity-40 disabled:cursor-not-allowed transition-all active:scale-95">
                        <i data-lucide="send" class="w-3.5 h-3.5 sm:w-4 sm:h-4"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import modules
        import { initDOM } from './js/dom.js';
        import { state } from './js/state.js';
        import { startCamera, stopCamera } from './js/camera.js';
        import { host, join, sendMessage as sendP2PMessage, disconnect as disconnectP2P, stopHosting } from './js/hosting.js';
        import { startDiscoveryHost, connectToDiscovery } from './js/discovery.js';
        import { showAlert } from './js/alert.js';
        
        // Make functions available globally
        window.host = host;
        window.join = join;
        window.sendP2PMessage = sendP2PMessage;
        window.disconnectP2P = disconnectP2P;
        window.stopHosting = stopHosting;

        // --- Logic ---
        const app = {
            user: null,
            status: 'idle', // idle, searching, connected, disconnected
            mode: 'text',
            roomId: null,
            searchInterval: null,
            localStream: null,
            lookingForMatch: false,

            // DOM Elements
            el: {
                welcomeScreen: document.getElementById('welcome-screen'),
                chatScreen: document.getElementById('chat-screen'),
                messagesContainer: document.getElementById('messages-container'),
                msgInput: document.getElementById('msg-input'),
                btnSend: document.getElementById('btn-send'),
                btnStopNext: document.getElementById('btn-stop-next'),
                statusInd: document.getElementById('status-indicator'),
                disconnectInd: document.getElementById('disconnect-indicator'),
                videoContainer: document.getElementById('video-container'),
                localVideo: document.getElementById('local-video'),
                noCameraMsg: document.getElementById('no-camera-msg'),
                videoWaitingMsg: document.getElementById('video-waiting-msg'),
                onlineCount: document.getElementById('online-count')
            },

            init: async function() {
                // Initialize DOM references
                initDOM();
                
                // Initialize theme system
                this.initTheme();
                
                // Initialize Lucide Icons
                lucide.createIcons();

                // Generate User ID
                this.user = { uid: 'user_' + Math.random().toString(36).substr(2, 9) };
                state.userId = this.user.uid;
                
                // Update online count
                this.updateOnlineCount();
                
                // Update online count periodically
                setInterval(() => {
                    this.updateOnlineCount();
                }, 5000); // Update every 5 seconds

                // Start discovery host (for session discovery)
                startDiscoveryHost();

                // Check for join parameter in URL
                const urlParams = new URLSearchParams(window.location.search);
                const joinCode = urlParams.get('join');
                if (joinCode) {
                    this.joinSession(joinCode);
                }

                // Input Listeners
                this.el.msgInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMessage();
                });

                // Global Key Listener
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.handleStopNext();
                });
            },

            // --- Core Actions ---

            startChat: async function(mode) {
                // Save mode to localStorage
                localStorage.setItem('codmegle_mode', mode);
                
                // Navigate to chat.html with mode parameter
                window.location.href = `chat.html?mode=${mode}`;
            },
            
            startMatching: async function() {
                this.lookingForMatch = true;
                
                // Strategy: Become a host first, then continuously search for available hosts via discovery
                // This way we're ready to accept connections immediately
                
                // Start hosting (this will generate a 5-character code and register with discovery)
                try {
                    await host();
                    
                    // Wait for host peer to be ready before searching
                    await new Promise((resolve) => {
                        if (state.peer && state.peer.open) {
                            resolve();
                        } else if (state.peer) {
                            state.peer.once('open', resolve);
                        } else {
                            setTimeout(resolve, 2000); // Fallback timeout
                        }
                    });
                    
                    // Continuously search for available hosts via discovery and connect
                    let isSearching = false; // Prevent concurrent searches
                    let attemptedPeers = new Set(); // Track attempted peers to avoid immediate retries
                    let currentConnectionAttempt = null; // Track current connection attempt
                    
                    const searchInterval = setInterval(async () => {
                        // Stop searching if already connected or not looking anymore
                        if (!this.lookingForMatch || state.isConnected) {
                            clearInterval(searchInterval);
                            this.searchInterval = null;
                            return;
                        }
                        
                        // Don't search if we're currently attempting a connection (unless it's been too long)
                        if (currentConnectionAttempt) {
                            // If we've been trying for more than 10 seconds, clear it and try next
                            return;
                        }
                        
                        // Prevent concurrent discovery calls
                        if (isSearching) {
                            return;
                        }
                        
                        isSearching = true;
                        try {
                            // Get sessions filtered by current mode (text or video)
                            const currentMode = this.mode || 'video';
                            const sessions = await connectToDiscovery(null, currentMode);
                            
                            // Filter out our own session, attempted peers, and get available Codmegle hosts
                            // Only 5-character codes are valid Codmegle sessions
                            // Also ensure mode matches (text with text, video with video)
                            const availableHosts = sessions.filter(s => {
                                // Strictly avoid self-connection - check against our current share code
                                const isNotSelf = s.code !== state.currentShareCode;
                                const isValidCode = s.code && s.code.length === 5;
                                const notAttempted = !attemptedPeers.has(s.code);
                                // Double-check: make sure code exists and is not empty
                                const hasValidCode = s.code && s.code.trim().length > 0;
                                // Ensure mode matches (text with text, video with video) - strict matching
                                const sessionMode = s.mode || 'video';
                                const modeMatches = sessionMode === currentMode;
                                if (!modeMatches) {
                                    console.log(`Filtering out session ${s.code}: mode mismatch (session: ${sessionMode}, current: ${currentMode})`);
                                }
                                return isNotSelf && isValidCode && notAttempted && hasValidCode && modeMatches;
                            });
                            
                            if (sessions.length > 0 && availableHosts.length < sessions.length) {
                                console.log(`Filtered: ${sessions.length - availableHosts.length} (self/attempted/invalid), ${availableHosts.length} available`);
                            }
                            
                            if (availableHosts.length > 0) {
                                // Randomly select a host from available ones
                                const randomIndex = Math.floor(Math.random() * availableHosts.length);
                                const selectedHost = availableHosts[randomIndex];
                                
                                console.log(`Found ${availableHosts.length} available hosts, attempting: ${selectedHost.code}`);
                                
                                // Mark as attempted
                                attemptedPeers.add(selectedHost.code);
                                
                                // Clear old attempts after a while (30 seconds)
                                if (attemptedPeers.size > 20) {
                                    console.log('Clearing old attempted peers list');
                                    attemptedPeers.clear();
                                }
                                
                                // Set current connection attempt
                                currentConnectionAttempt = selectedHost.code;
                                
                                // Wait a moment for peer readiness
                                await new Promise(resolve => setTimeout(resolve, 1000));
                                
                                // Double-check we're still looking
                                if (!this.lookingForMatch || state.isConnected) {
                                    currentConnectionAttempt = null;
                                    isSearching = false;
                                    return;
                                }
                                
                                // Attempt connection directly - join() will handle it
                                // Set timeout to clear attempt if not connected
                                currentConnectionAttempt = selectedHost.code;
                                
                                // Call join directly - it will set up the connection
                                join(selectedHost.code);
                                
                                // Set timeout to clear attempt flag if connection fails
                                setTimeout(() => {
                                    if (!state.isConnected && currentConnectionAttempt === selectedHost.code) {
                                        console.log(`Connection to ${selectedHost.code} failed/timed out, will try next peer`);
                                        currentConnectionAttempt = null;
                                    }
                                }, 12000); // 12 second timeout
                            } else {
                                // No available hosts - clear old attempts to retry them
                                if (attemptedPeers.size > 10) {
                                    console.log('No new peers, clearing attempted list to retry');
                                    attemptedPeers.clear();
                                }
                                console.log('No available hosts found, waiting...');
                            }
                        } catch (err) {
                            console.warn("Discovery error:", err);
                            // Continue searching
                        } finally {
                            isSearching = false;
                        }
                    }, 2000); // Search every 2 seconds for faster matching
                    
                    // Store interval so we can clear it if needed
                    this.searchInterval = searchInterval;
                    
                } catch (err) {
                    console.error("Failed to start hosting:", err);
                    showAlert("Failed to start connection. Please try again.", 'error');
                    this.status = 'idle';
                    state.isSearching = false;
                    this.updateUIState();
                }
            },
            
            joinSession: function(code) {
                // Navigate to chat.html with join code
                window.location.href = `chat.html?join=${code}`;
            },

            handleStopNext: function() {
                if (this.status === 'connected' || this.status === 'searching') {
                    // Stop current connection
                    this.disconnectChat();
                } else if (this.status === 'disconnected') {
                    // Start New Chat - fully reset and start fresh
                    this.disconnectChat(); // Ensure clean
                    
                    // Small delay to ensure cleanup completes
                    setTimeout(() => {
                        this.startChat(this.mode);
                    }, 500);
                }
            },

            disconnectChat: function() {
                // Send disconnect message and close P2P connection
                disconnectP2P();
                stopHosting();
                
                // Stop camera if in video mode
                if (this.mode === 'video') {
                    this.stopCamera();
                }
                
                this.stopBroadcastingSearch();
                this.status = 'disconnected';
                this.lookingForMatch = false;
                state.isConnected = false;
                state.isSearching = false;
                
                // Clear messages
                this.el.messagesContainer.innerHTML = '<div class="text-center py-4"><div class="inline-flex items-center gap-2 px-4 py-2 rounded-full" style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%); border: 1px solid var(--status-error);"><i data-lucide="alert-circle" class="w-4 h-4" style="color: var(--status-error);"></i><span class="text-sm font-medium" style="color: var(--status-error);">Stranger has disconnected.</span></div></div>';
                if (window.lucide) {
                    lucide.createIcons();
                }
                
                this.updateUIState();
            },

            sendMessage: function() {
                const text = this.el.msgInput.value.trim();
                if (!text || this.status !== 'connected' || !state.isConnected) return;

                const msgPayload = {
                    type: 'CHAT',
                    sender: this.user.uid,
                    text: text,
                    timestamp: Date.now()
                };

                // Add to local UI
                this.appendMessage(msgPayload);

                // Send via P2P data connection
                if (!sendP2PMessage(text, this.user.uid)) {
                    showAlert("Message could not be sent. Connection may be lost.", 'warning');
                }

                this.el.msgInput.value = '';
            },

            // --- Matchmaking Logic ---

            stopBroadcastingSearch: function() {
                if (this.searchInterval) {
                    clearInterval(this.searchInterval);
                    this.searchInterval = null;
                }
                this.lookingForMatch = false;
            },

            // --- Media Helper ---
            
            startCamera: async function() {
                try {
                    const stream = await startCamera();
                    this.localStream = stream;
                    if (this.el.localVideo) {
                        this.el.localVideo.srcObject = stream;
                        this.el.localVideo.classList.remove('hidden');
                        // Ensure video plays
                        try {
                            await this.el.localVideo.play();
                        } catch (playErr) {
                            console.warn("Video play error:", playErr);
                        }
                    }
                    if (this.el.noCameraMsg) {
                        this.el.noCameraMsg.classList.add('hidden');
                    }
                } catch (e) {
                    console.error("Camera error", e);
                    if (this.el.localVideo) {
                        this.el.localVideo.classList.add('hidden');
                    }
                    if (this.el.noCameraMsg) {
                        this.el.noCameraMsg.classList.remove('hidden');
                    }
                    throw e;
                }
            },

            stopCamera: function() {
                stopCamera();
                this.localStream = null;
                if (this.el.localVideo) {
                    this.el.localVideo.srcObject = null;
                }
            },

            // --- UI Helpers ---

            updateUIState: function() {
                const isConnected = this.status === 'connected';
                const isSearching = this.status === 'searching';
                const isDisconnected = this.status === 'disconnected';

                // Controls
                this.el.msgInput.disabled = !isConnected;
                this.el.btnSend.disabled = !isConnected;
                this.el.msgInput.placeholder = isConnected ? "Type your message..." : (isDisconnected ? "Stranger disconnected" : "Waiting for connection...");
                
                // Button Text
                if (isDisconnected) {
                    this.el.btnStopNext.className = "h-11 sm:h-12 px-4 sm:px-6 font-bold rounded-xl shadow-md text-xs sm:text-sm uppercase tracking-wide transition-all bg-gradient-primary hover:shadow-lg text-white active:translate-y-0.5 flex-shrink-0 justify-center items-center";
                    this.el.btnStopNext.innerHTML = '<span class="flex items-center gap-1.5"><i data-lucide="refresh-cw" class="w-4 h-4"></i><span>New Chat</span></span><span class="ml-1 text-xs text-blue-200 hidden sm:block -mt-0.5">Esc</span>';
                    this.el.btnStopNext.style.border = 'none';
                } else {
                    this.el.btnStopNext.className = "h-11 sm:h-12 px-4 sm:px-6 font-bold rounded-xl shadow-md text-xs sm:text-sm uppercase tracking-wide transition-all border-2 active:translate-y-0.5 flex-shrink-0 justify-center items-center";
                    this.el.btnStopNext.style.backgroundColor = 'var(--button-secondary-bg)';
                    this.el.btnStopNext.style.borderColor = 'var(--button-secondary-border)';
                    this.el.btnStopNext.style.color = 'var(--text-primary)';
                    this.el.btnStopNext.innerHTML = '<span class="flex items-center gap-1.5"><i data-lucide="arrow-right" class="w-4 h-4"></i></span><span class="ml-1 text-xs hidden sm:block -mt-0.5" style="color: var(--text-tertiary);">Esc</span>';
                }
                
                // Re-initialize icons after button update
                if (window.lucide) {
                    lucide.createIcons();
                }

                // Indicators
                this.el.statusInd.classList.toggle('hidden', !isSearching);
                this.el.disconnectInd.classList.toggle('hidden', !isDisconnected);
                this.el.videoWaitingMsg.classList.toggle('hidden', !isSearching);

                // Auto Focus
                if (isConnected) this.el.msgInput.focus();
            },

            appendMessage: function(msg) {
                const isMe = msg.sender === this.user.uid;
                const div = document.createElement('div');
                div.className = `message-bubble flex ${isMe ? 'justify-end' : 'justify-start'} mb-3`;
                
                const time = new Date(msg.timestamp);
                const timeStr = time.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
                
                div.innerHTML = `
                    <div class="flex flex-col ${isMe ? 'items-end' : 'items-start'} max-w-[75%] md:max-w-[60%]">
                        <div class="flex items-center gap-2 mb-1 px-1">
                            <span class="text-xs font-semibold" style="color: ${isMe ? 'var(--accent-primary)' : 'var(--text-secondary)'};">${isMe ? 'You' : 'Stranger'}</span>
                            <span class="text-xs" style="color: var(--text-tertiary);">${timeStr}</span>
                        </div>
                        <div class="px-4 py-2.5 rounded-2xl shadow-md ${isMe ? 'bg-gradient-message-you text-white rounded-br-sm' : 'bg-gradient-message-stranger rounded-bl-sm'}" style="${!isMe ? 'border: 1px solid var(--message-stranger-border); color: var(--text-primary);' : ''}">
                            <p class="break-words text-sm leading-relaxed">${this.escapeHtml(msg.text)}</p>
                        </div>
                    </div>
                `;
                this.el.messagesContainer.appendChild(div);
                this.el.messagesContainer.scrollTop = this.el.messagesContainer.scrollHeight;
                
                // Re-initialize icons for new message
                if (window.lucide) {
                    lucide.createIcons();
                }
            },

            escapeHtml: function(unsafe) {
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            },
            
            updateOnlineCount: async function() {
                try {
                    // Get all sessions (no mode filter for count)
                    const allSessions = await connectToDiscovery();
                    // Count only valid Codmegle sessions (5-character codes)
                    const validSessions = allSessions.filter(s => s.code && s.code.length === 5);
                    const count = validSessions.length;
                    this.el.onlineCount.innerText = count > 0 ? count.toLocaleString() + ' online' : 'Connecting...';
                } catch (err) {
                    console.warn("Error updating online count:", err);
                    this.el.onlineCount.innerText = '... online now';
                }
            },
            
            // Theme Management
            initTheme: function() {
                // Check for saved theme preference or system preference
                const savedTheme = localStorage.getItem('codmegle_theme');
                const systemPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                
                let theme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
                this.setTheme(theme);
                
                // Listen for system theme changes
                if (window.matchMedia) {
                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                        if (!localStorage.getItem('codmegle_theme')) {
                            this.setTheme(e.matches ? 'dark' : 'light');
                        }
                    });
                }
            },
            
            setTheme: function(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                localStorage.setItem('codmegle_theme', theme);
                
                // Update theme toggle icon
                const themeToggle = document.getElementById('theme-toggle');
                if (themeToggle) {
                    const lightIcon = themeToggle.querySelector('.theme-icon-light');
                    const darkIcon = themeToggle.querySelector('.theme-icon-dark');
                    if (lightIcon && darkIcon) {
                        if (theme === 'dark') {
                            lightIcon.classList.add('hidden');
                            darkIcon.classList.remove('hidden');
                        } else {
                            darkIcon.classList.add('hidden');
                            lightIcon.classList.remove('hidden');
                        }
                    }
                }
                
                // Reinitialize icons
                if (window.lucide) {
                    lucide.createIcons();
                }
            },
            
            toggleTheme: function() {
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                this.setTheme(newTheme);
            }
        };

        // Make app available globally
        window.app = app;
        
        // Run
        window.onload = function() {
            app.init();
        };

    </script>
</body>
</html>